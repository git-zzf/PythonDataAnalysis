[TOC]

# 本周课程导学

重点讲解表示数据的基本方法

介绍`Numpy`第三方库

重点讲解`Numpy`中的`ndarray`类型和操作这个类型的基本的函数和保存读取数据的基本方法

实现图像的手绘效果

****

# 数据的维度

从一个数据到一组数据：

+ 一个数据表达一个含义
+ 一组数据可能是一个观测值，也可能是几个现象的几个观测值表示了多个含义，在理解一组数据的时候，需要知道这组数据表达含义的个数



## 维度

一组数据的组织形式

一维方向展开：`3.1404、3.1413、3.1401、3.1398、3.1349、3.1376`

二维方向展开：`3.1404、3.1413、3.1401`

​					   	`3.1398、3.1349、3.1376`

多个维度展开使得数据表达多个含义



### 一维数据

由对等关系的有序或无序数据构成，采用线性方式组织

在表示一维数据的时候：可以使用`Python`提供的数据类型，包括`列表`、`数组`和`集合`。

+ 列表和数组

  + 都是表达一组数据的有序结构的数据类型

  + 列表中每一个元素的数据类型可以不同（浮点 ，字符串，列表等）

    ```python
    [3.1413, 'pi', 3.1404, [3.1401, 3.1349], '3.1376']
    ```

  + 数组要求每一个元素的数据类型都相同（全都是浮点）

    ```c
    float a[6] = {3.1413, 3.1398, 3.1404, 3.1401, 3.1349, 3.1376};
    ```



### 二维数据

由多个一维数据构成，是一维数据的组合形式

例如：表格（表格中的表头可以是二维数据的一部分，也可以是二维数据之外的部分）



## 多维数据

由一维或二维数据在新维度上扩展形成

例如：多个年份的排行榜表格形成的集合，增加了一个时间维度，变成多维数据



## 高维数据

高维数据仅使用最基本的二元关系就可以展示数据间的复杂结构

例如：

```json
{
    "firstName" : "Tian",
    "lastName"  : "Song",
    "address"   : {
        			"streetAddr" : "中关村南大街5号",
        			"city"       : "北京市",
        			"zipcode"    : "100081"
    			  } ,
    "prof"		: [ "Computer System" , "Security" ]
}
```

这里的数据没有规整的组织方式（表格），但是却有数据之间的包含关系，数据之间的并列关系，属性关系等，形成了一个数据的组织方式（键值对）

****



## 数据维度的Python展示

一维数据：列表和集合类型

+ 列表是有序关系：`[3.1398, 3.1349, 3.1376]`
+ 集合是无序关系：`{3.1398, 3.1349, 3.1376}`

二维数据：列表类型

多维数据：列表类型

+ 例子：多维列表，列表中的每一个元素都是一个列表

```python
[[3.1398, 3.1349, 3.1376],
 [3.1413, 3.1404, 3.1401]]
```

高维数据：字典类型或数据表示格式

+ 例子：字典类型，由键值对构成的数据类型

```python
dict = {
    "firstName" : "Tian",
    "lastName"  : "Song",
}
```



国际公认的数据表达形式由三种：JSON, XML, YAML

****



# `NumPy`的数组对象：`ndarray`



## `NumPy`

`NumPy`是一个开源的`Python`科学计算基础库，提供了很多功能：

+ 提供了一个强大的表示N维数组的对象`ndarray`
+ 提供了一组广播功能的函数用来在数组之间进行计算
+ `NumPy`整合了`C/C++/Fortran`代码，并且提供这些代码的工具
+ 提供了线性代数，傅里叶变换，随机数生成等功能

`Numpy`是`SciPy`、`Pandas`等数据处理或科学计算库的基础





## 使用`NumPy`

使用方法：

```python
import numpy as np
```

 建议使用约定的引用方式





## `ndarray`

例：计算 A<sup>2</sup>+B<sup>3</sup>，其中，A和B是一维数组

+ 传统写法：

```python
def pySum():
    a = [0, 1, 2, 3, 4]
    b = [9, 8, 7, 6, 5]
    c = []
    
    for i in range(len(a)):
        c.append(a[i]**2 + b[i]**3)
	return c

print(pySum())
```

这种写法，关注点在每一个元素的运算上，不是一种科学计算的思维

+ `NumPy`写法：

分别生成数组a和b，直接进行运算，不需要循环

```python
import numpy as np

def npSum():
    a = np.array([0, 1, 2, 3, 4])
    b = np.array([9, 8, 7, 6, 5])
    
    c = a**2 + b**3
    
    return c

print(npSum())
```

这里的思想是把数组a和数组b当成两个数据，当这两个数据维度相同时可以直接进行运算。程序会帮助我们对每一个元素进行运算，而程序员只需要考虑a和b是数据就可以了。

****

为什么需要一个数组类型？

+ 数组对象可以去掉元素间运算所需的循环，使一维向量更像单个数据
+ 通过设置专门的数组对象，经过优化提升这类应用的运算速度。NumPy的底层实现是由C来完成的，非常高效。

+ 通过观察，可以发现在科学计算中，一个维度所有数据的类型往往相同，因此，采用数组对象有助于节省运算和存储空间（对于内存分配上来说，如果存储的数据类型相同，就有利于分配内存）



## `ndarray`构成

`ndarray`是一个多维数组，由两部分构成：

+ 实际存储的数据
+ 描述这些数据的元数据（数据维度、数据类型等）

在`ndarray` 的定义中，数组一般来说要求所有元素类型相同，数组下标从0开始

实例：

`IPython`提示符

```IPython
In [19]: a = np.array([[0, 1, 2, 3, 4],
    ...:               [9, 8, 7, 6, 5]])

In [20]: a
Out[20]:
array([[0, 1, 2, 3, 4],
	   [9, 8, 7, 6, 5]])

In [21]: print(a)
([[0, 1, 2, 3, 4],
  [9, 8, 7, 6, 5]])
```

`In [19]`，`Out[20]`等就是`IPython`的提示符，后面是输入输出

在程序中，`ndarray`的别名是`array`，所以可以用`np.array()`生成一个`ndarray`数组

当这个数组显示的时候（输出`a`变量），数组前面有一个`array`加上一个括号来表明这个数组的类型

当打印这个数组的时候，`np.array`采用方括号的形式来表示它的维度关系，元素由空格分离

对于描述`ndarray`有两个基本概念：

+ 轴（axis）：保存数据的维度
+ 秩（rank）：轴的数量



## `ndarray`对象的属性

| 属性        | 说明                                           |
| ----------- | ---------------------------------------------- |
| `.ndim`     | 秩，即轴的数量或维度的数量                     |
| `.shape`    | `ndarray`对象的尺度，对于矩阵，n行n维m列       |
| `.size`     | `ndarray`对象元素的个数，相当于.shape中n*m的值 |
| `.dtype`    | `ndarray`对象的元素类型                        |
| `.itemsize` | `ndarray`对象中每个元素的大小，以字节为单位    |

实例：

注意：`a = np.array([[0, 1, 2, 3, 4],  [9, 8, 7, 6, 5]])`有两层方括号

```python
>>> import numpy as np
>>> a = np.array([[0, 1, 2, 3, 4], 
                [9, 8, 7, 6, 5]])

>>> a.ndim
2

>>> a.shape
(2,5)

>>> a.size
10

>>>a.dtype
dtpe('int32')

>>> a.itemsize
4
```

`int32`元素类型在`Python`中并不存在，是`NumPy`定义的数据类型，除了`int32`的元素，`ndarray`还有其它的元素类型



## `ndarray`的元素类型

| 数据类型 | 说明                                                      |
| -------- | --------------------------------------------------------- |
| `bool`   | 布尔类型，True或False                                     |
| `intc`   | 与C语言中的`int`类型一直，一般是`int32`或`int64`          |
| `intp`   | 用于索引的整数，与C语言中`ssize_t`一致，`int32`或`int64`  |
| `int8`   | 字节长度的整数，取值：[-128, 127]                         |
| `int16`  | 16位长度的整数，取值：[-372768, 32767]                    |
| `int32`  | 32位长度的整数，取值：[-2<sup>31</sup>, 2<sup>31</sup>-1] |
| `int64`  | 64位长度的整数，取值：[-2<sup>63</sup>, 2<sup>63</sup>-1] |

无符号整数以及浮点数类型：

| 数据类型  | 说明                                            |
| --------- | ----------------------------------------------- |
| `uint8`   | 8位无符号整数，取值：[0, 255]                   |
| `uint16`  | 16位无符号整数，取值：[0, 65535]                |
| `uint32`  | 32位无符号整数，取值：[0, 2<sup>32</sup>-1]     |
| `uint64`  | 64位无符号整数，取值：[0, 2<sup>64</sup>-1]     |
| `float16` | 16位半精度浮点数：1位符号位，5位指数，10位尾数  |
| `float32` | 16位半精度浮点数：1位符号位，8位指数，23位尾数  |
| `float64` | 16位半精度浮点数：1位符号位，11位指数，52位尾数 |

`ndarray`还支持两种复数类型，由`实部(.real) + j虚部(.imag)`构成：

| 数据类型     | 说明                               |
| ------------ | ---------------------------------- |
| `complex64`  | 复数类型，实部和虚部都是32位浮点数 |
| `complex128` | 复数类型，实部和虚部都是64位浮点数 |

对比`Python`语法，为什么`ndarray`需要这么多种数据类型？

+ `Python`语法仅支持整数、浮点数和复数3种类型，其中整数类型没有划分取值范围，浮点数和复数都只有一种。
+ 在科学计算中，涉及数据较多，对存储和性能都有较高要求
+ 因此需要对元素类型精细定义，有助于`NumPy`合理使用存储空间并优化性能
+ 而且也有助于程序员对程序规模有合理评估，对于`Python`程序，由于没有精确定义实际存储空间，所以很难预估一个程序的使用空间



## 非同质对象构成的`ndarray`数组

实例：

```python
>>> import numpy as np
>>> x = np.array([[0, 1, 2, 3, 4], 
                [9, 8, 7, 6]])

>>> x.shape
(2,)

>>>x.dtype
dtype('O')

>>> x
array([list([0, 1, 2, 3, 4]), list([9, 8, 7, 6])], dtype=object)

>>> a.size
2

>>> a.itemsize
4
```

`x`数组包含一个5个元素的列表和一个4个元素的列表

查看`x.shape`发现结果是`(2,)`，我们只知道这是2个元素，但是没有更进一步的维度分析

用`x.dtype`查看数据类型发现，发现返回的结果是`dtype('o')`，`'o'`是一种对象类型，也就是说当`ndarray`的元素的类型并不相同的时候，或者每一个元素的维度数不相同的时候，`ndarray`将每个元素认为是一个对象。

事实上，当`ndarray`的数据类型中每个元素都是一个对象的时候，它又变成了一个同质的数组类型，不过当我们在使用数据的时候，会发现数据的类型是不同的

这种情况叫非同质的`ndarray`对象，当`ndarray`是非同质的时候，它无法有效发挥`NumPy`的优势，所以在进行大规模数据处理的时候，尽量避免使用非同质的`ndarray`对象



****

# `ndarray`数组的创建和变换

## 创建方法

+ 从`Python`中的列表或元组等类型创建`ndarray`数组
+ 使用`NumPy`中相关的函数来创建`ndarray`数组，如：`arange`，`ones`，`zeros`等
+ 从字节流（raw bytes）中创建`ndarray`数组
+ 从文件中读取相关的格式，创建`ndarray`数组



## 从`Python`中的列表或元组等类型创建`ndarray`数组

使用`NumPy`函数，把列表和元组作为参数输入：

```python
x = np.array(list/tuple)
```

可以在创建的时候指定每一个元素的数据类型：

```python
x = np.array(list/tuple, dtype=np.float32)
```

当`np.array()`不指定类型（`dtype`）时，`NumPy`将根据数据情况关联一个`dtype`类型，例如全都是整数，浮点数等

例子：

```python
>>> x = np.array([0, 1, 2, 3]) # 从列表类型创建

>>> print(x)
[0 1 2 3]

>>> x = np.array((4, 5, 6, 7)) # 从元组类型创建

>>> print(x)
[4 5 6 7]

>>> x = np.array([[1, 2], [9, 8], (0.1, 0.2)]) # 从列表和元组混合类型创建

>>> print(x)
[[1.  2. ]
 [9.  8. ]
 [0.1 0.2]]
```

混合使用创建数组时，只要列表和元组包含的数据个数相同就可以混合使用



## 使用`NumPy`中相关的函数来创建`ndarray`数组

| 函数                 | 说明                                               |
| -------------------- | -------------------------------------------------- |
| `np.arange(n)`       | 类似`range()`函数，返回`ndarray`类型，元素从0到n-1 |
| `np.ones(shape)`     | 根据`shape`生成一个全1数组，`shape`是元组类型      |
| `np.zeros(shape)`    | 根据`shape`生成一个全0数组，`shape`是元组类型      |
| `np.full(shape,val)` | 根据`shape`生成一个数组，每个元素值都是`val`       |
| `np.eye(n)`          | 创建一个正方的`n*n`单位矩阵，对角线为1，其余为0    |

例子：

```python
>>> np.arange(10)
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

>>> np.ones((3,6))
array([[1., 1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1., 1.]])

>>> np.zeros((3,6), dtype=np.int32)
array([[0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0]])

>>> np.eye(5)
array([[1., 0., 0., 0., 0.],
       [0., 1., 0., 0., 0.],
       [0., 0., 1., 0., 0.],
       [0., 0., 0., 1., 0.],
       [0., 0., 0., 0., 1.]])
```

`ones()`，`zeors()`，`eye()`函数生成的数组的元素都是浮点数类型，除非用户通过`dtype`来指定。而`arange()`函数生成的数组是整数类型。

除了二维数组，也可以生成多维数组：

```python
>>> np.ones((2,3,4))
array([[[1., 1., 1., 1.],
        [1., 1., 1., 1.],
        [1., 1., 1., 1.]],

       [[1., 1., 1., 1.],
        [1., 1., 1., 1.],
        [1., 1., 1., 1.]]])

>>> x = np.ones((2,3,4))
>>> print(x)
[[[1. 1. 1. 1.]
  [1. 1. 1. 1.]
  [1. 1. 1. 1.]]

 [[1. 1. 1. 1.]
  [1. 1. 1. 1.]
  [1. 1. 1. 1.]]]

>>> x.shape
(2, 3, 4)
```

数组的维度是：`(2,3,4)`表示这个数组有两个元素，每个元素又有三个维度，每个维度下有4个元素

注意：如果直接生成数组，会得到一个数组并且前面有数据类型的标识，比如：`array`。如果用一个变量去接收这个数组，再打印这个变量，则会得到数组本身

除了上述的函数以外，还有三个类似的函数，在进行大规模的科学计算的时候，这三个函数很重要：

| 函数                  | 说明                                           |
| --------------------- | ---------------------------------------------- |
| `np.ones_like(a)`     | 根据数组a的形状生成一个全1数组                 |
| `np.zeros_like(a)`    | 根据数组a的形状生成一个全0数组                 |
| `np.full_like(a,val)` | 根据数组a的形状生成一个数组，每个元素值都是val |

此外还有两个函数，可以生成序列：

| 函数               | 说明                                     |
| ------------------ | ---------------------------------------- |
| `np.linspace()`    | 根据起始止数据等间距地填充数据，形成数组 |
| `np.concatenate()` | 将两个或多个数组合并成一个新的数组       |

例子：

```python
>>> a = np.linspace(1, 10, 4)
>>> a
array([ 1.,  4.,  7., 10.])

>>> b = np.linspace(1, 10, 4, endpoint=False)
>>> b
array([1.  , 3.25, 5.5 , 7.75])

>>> c = np.concatenate((a,b))
>>> c
array([ 1.  ,  4.  ,  7.  , 10.  ,  1.  ,  3.25,  5.5 ,  7.75])
```

`endpoint`参数表示是否包括最后的元素（即10），默认为包括最后的元素

+ 为什么`NumPy`默认生成浮点数？

因为主要处理科学计算，在科学计算中，使用的往往都是浮点数



## `ndarray`数组的变换

包含“维度变换”和“元素类型变换”



## 维度变换的常用方法：

| 方法                 | 说明                                                  |
| -------------------- | ----------------------------------------------------- |
| `.reshape(shape)`    | 不改变数组元素，返回一个`shape`形状的数组，原数组不变 |
| `.resize(shape)`     | 与`.reshape()`功能一致，但修改原数组                  |
| `.swaoaxes(ax1,ax2)` | 将数组n个维度中两个维度进行调换                       |
| `.flatten()`         | 对数组进行降维，返回折叠后的一维数组，原数组不变      |

要注意：使用什么方法会改变原数组，什么方法不改变原数组

+ `.reshape()`例子：

```python
>>> a = np.ones((2,3,4), dtype=np.int32)
>>> a.reshape((3,8))
array([[1, 1, 1, 1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 1]])

>>> a
array([[[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]],

       [[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]]])
```

不改变原数组，输出之前的数组保持不变

+ `.resize()`例子：

```python
>>> a = np.ones((2,3,4), dtype=np.int32)
>>> a.resize((3,8))

>>> a
array([[1, 1, 1, 1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 1]])
```

`a.resize((3,8))`没有返回的结果，函数直接修改原数组，输出原数组发现原数组被变换了

+ `.flatten()`例子：

```python
>>> a = np.ones((2,3,4), dtype=np.int32)
>>> a.flatten()
array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
       1, 1])

>>> a
array([[[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]],

       [[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]]])

>>> b = a.flatten()
>>>b
array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
       1, 1])
```

`a.flatten()`函数不会改变`a`数组本身



## 数组的类型变换：

`new_a = a.astype(new_type)`

例子：

```python
>>> a = np.ones((2,3,4), dtype = np.int)
>>> a
array([[[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]],

       [[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]]])
```

这里首先生成一个数组，类型是`np.int`，事实上，`NumPy`中并没有`np.int`类型，这个类型意思是整数类型这一类，程序会将元素解析为整数类型，具体是`int32`还是`int64`是由程序自动调节，所以可以简写为`np.int`而不用具体到`np.int32`

```python
>>> b = a.astype(np.float)
>>> b
array([[[1., 1., 1., 1.],
        [1., 1., 1., 1.],
        [1., 1., 1., 1.]],

       [[1., 1., 1., 1.],
        [1., 1., 1., 1.],
        [1., 1., 1., 1.]]])
```

`.astype()`方法会生成一个新数组，如果将转换的类型设置成和原来的一样，那么就可以复制原来的数组了，这样做可以提高性能，节省空间



## 数组向列表的转换

`.tolist()`例子：

```python
>>> a = np.full((2,3,4), 25, dtype=np.int32)
>>> a
array([[[25, 25, 25, 25],
        [25, 25, 25, 25],
        [25, 25, 25, 25]],

       [[25, 25, 25, 25],
        [25, 25, 25, 25],
        [25, 25, 25, 25]]])

>>> a.tolist()
[[[25, 25, 25, 25], [25, 25, 25, 25], [25, 25, 25, 25]],
 [[25, 25, 25, 25], [25, 25, 25, 25], [25, 25, 25, 25]]]
```

列表是`Python`自带的数据类型，比起数组类型，运算速度要慢很多

不过在与原生`Python`语言相适应的地方，可以使用这个函数转换成列表



****

# `ndarray`数组的操作

对数组的索引和切片

索引：获取数组中特定位置元素

切片：获取数组中元素子集的过程



## 一维数组的索引和切片

与`Python`的列表类似

```python
>>> a = np.array([9, 8, 7, 6, 5])
>>> a[2]
7

>>> a[ 1 : 4 : 2 ] # 起始 : 终止（不含） : 步长
array([8, 6])
```



## 多维数组的索引和切片

索引：

```python
>>> a = np.arange(24).reshape((2,3,4)) # 定义为整数数组
>>> a
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],

       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]])

>>> a[1, 2, 3]
23

>>> a[0, 1, 2]
6

>>> a[-1, -2, -3] # 尾部是从-1开始计算
17
```

切片：

```python
>>> a = np.arange(24).reshape((2,3,4)) 
>>> a
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],

       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]])

>>> a[:, 1, -3]	# 选取一整个维度
array([ 5, 17])

>>> a[:, 1:3, :]	# 每个维度切片方法与一维数组相同
array([[[ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],

       [[16, 17, 18, 19],
        [20, 21, 22, 23]]])

>>> a[:, :, ::2]	# 每个维度可以使用步长跳跃切片，
					# 对于第三个维度，不关心起始和结束，但是要求以2为步长
array([[[ 0,  2],
        [ 4,  6],
        [ 8, 10]],

       [[12, 14],
        [16, 18],
        [20, 22]]])
```

对于数组每一个维度都可以使用两个冒号来进行切片

对于高维数组使用切片可能会不直观，不好理解，所以要小心使用参数



****

# `ndarray`数组的运算

## 数组与标量的运算

`ndarray`数组是一个n维的数组，可以与标量进行运算

数组与标量之间的运算作用于数组的每一个元素

实例：计算a与元素平均值的商

```python
>>> a = np.arange(24).reshape((2,3,4))
>>> a
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],

       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]])

>>> a.mean() # 平均值
11.5

>>>sum = 0	# a.maen()等同于所有元素求和再除元素个数
>>> for i in range(2):
    for j in range(3):
        for k in range(4):
            sum + = a[i,j,k]
sum = sum / 24
>>> sum
11.5

>>> a = a / a.mean()
>>> a
array([[[0.        , 0.08695652, 0.17391304, 0.26086957],
        [0.34782609, 0.43478261, 0.52173913, 0.60869565],
        [0.69565217, 0.7826087 , 0.86956522, 0.95652174]],

       [[1.04347826, 1.13043478, 1.2173913 , 1.30434783],
        [1.39130435, 1.47826087, 1.56521739, 1.65217391],
        [1.73913043, 1.82608696, 1.91304348, 2.        ]]])
```



## `NumPy`中的一元函数（对各元素运算）

对单一的`ndarray`数组进行相关运算的函数，这些函数对数组的运算实际上是对数组中每一个元素的运算：

| 函数                                   | 说明                                        |
| -------------------------------------- | ------------------------------------------- |
| `np.abs(x)` `np.fabs(x)`               | 计算数组各元素的绝对值                      |
| `np.sqrt(x)`                           | 计算数组各元素的平方根                      |
| `np.square(x)`                         | 计算数组各元素的平方                        |
| `np.log(x)` `np.log10(x)` `np.log2(x)` | 计算数组各元素的自然对数、10底对数和2底对数 |
| `np.ceil(x)` `np.floor(x)`             | 计算数组各元素的`ceiling`值或`floor`值      |

``fabs()`只适用于`float`和`integer`类型，`.abs()`也适用于复数

`ceiling`是大于等于元素的最小整数，`floor`是小于等于元素的最大整数，对于12.9，`ceiling`值是13，`floor`值是12

| 函数                                                         | 说明                                               |
| ------------------------------------------------------------ | -------------------------------------------------- |
| `np.rint(x)`                                                 | 计算数组各元素的四舍五入值                         |
| `np.modf(x)`                                                 | 将数组各元素的小数和整数部分以两个独立数组形式返回 |
| `np.cos(x)` `np.cosh(x)` <br>`np.sin(x)` `np.sinh(x)` <br>`np.tan(x)` `np.tanh(x)` | 计算数组各元素的三角函数和双曲函数                 |
| `np.exp(x)`                                                  | 计算数组各元素的指数值                             |
| `np.sign(x)`                                                 | 计算数组各元素的符号值，返回的结果是1、0或 -1      |

一元函数实例：

```python
>>> a = np.arange(24).reshape((2,3,4))
>>> np.square(a)
array([[[  0,   1,   4,   9],
        [ 16,  25,  36,  49],
        [ 64,  81, 100, 121]],

       [[144, 169, 196, 225],
        [256, 289, 324, 361],
        [400, 441, 484, 529]]], dtype=int32) 
# 这里int32是属性，通过np.square(a).dtype可以查看
# 通过.square()函数生成了一个新的数组，并没有改变之前的数组

>>> a = np.sqrt(a)
>>> a
array([[[0.        , 1.        , 1.41421356, 1.73205081],
        [2.        , 2.23606798, 2.44948974, 2.64575131],
        [2.82842712, 3.        , 3.16227766, 3.31662479]],

       [[3.46410162, 3.60555128, 3.74165739, 3.87298335],
        [4.        , 4.12310563, 4.24264069, 4.35889894],
        [4.47213595, 4.58257569, 4.69041576, 4.79583152]]])
# 这里开平方，即使是整数（例如1）也是浮点数的数据类型

>>> np.modf(a)
(array([[[0.        , 0.        , 0.41421356, 0.73205081],
         [0.        , 0.23606798, 0.44948974, 0.64575131],
         [0.82842712, 0.        , 0.16227766, 0.31662479]],
 
        [[0.46410162, 0.60555128, 0.74165739, 0.87298335],
         [0.        , 0.12310563, 0.24264069, 0.35889894],
         [0.47213595, 0.58257569, 0.69041576, 0.79583152]]]),
 array([[[0., 1., 1., 1.],
         [2., 2., 2., 2.],
         [2., 3., 3., 3.]],
 
        [[3., 3., 3., 3.],
         [4., 4., 4., 4.],
         [4., 4., 4., 4.]]]))
```

几乎所有的一元函数都是新生成数组，如果希望改变原来的数组需要赋值给之前的数组



## `NumPy`的二元函数

两个数组之间的运算

| 函数                                                         | 说明                                     |
| ------------------------------------------------------------ | ---------------------------------------- |
| `+` `-` `*` `/` `**`                                         | 两个数组各元素进行对应运算               |
| `np.maximum(x,y)` `np.fmax()` <br>`np.maximum(x,y)` `np.fmin()` | 元素级的最大值/最小值计算                |
| `np.mod(x,y)`                                                | 元素级的模运算                           |
| `np.copysign(x,y)`                                           | 将数组y中各元素的符号赋值给数组x对应元素 |
| `>` `<` `>=` `<=` `==` `!=`                                  | 算术比较，产生布尔型数组                 |

二元函数实例：

```python
>>> a = np.arange(24).reshape((2,3,4))
>>> b = np.sqrt(a)
>>> a
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],

       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]])

>>> b
array([[[0.        , 1.        , 1.41421356, 1.73205081],
        [2.        , 2.23606798, 2.44948974, 2.64575131],
        [2.82842712, 3.        , 3.16227766, 3.31662479]],

       [[3.46410162, 3.60555128, 3.74165739, 3.87298335],
        [4.        , 4.12310563, 4.24264069, 4.35889894],
        [4.47213595, 4.58257569, 4.69041576, 4.79583152]]])

>>> np.maximum(a,b)
array([[[ 0.,  1.,  2.,  3.],
        [ 4.,  5.,  6.,  7.],
        [ 8.,  9., 10., 11.]],

       [[12., 13., 14., 15.],
        [16., 17., 18., 19.],
        [20., 21., 22., 23.]]])
# 由于b中元素是a的平方根所以a的元素要大于b的元素
# 不过这里看到的数据并不是a中的元素，而是浮点数
# 所以.maximum()函数不只是把大的数复制过来，而是一种运算，运算结果生成的是浮点数

>>> a > b
array([[[False, False,  True,  True],
        [ True,  True,  True,  True],
        [ True,  True,  True,  True]],

       [[ True,  True,  True,  True],
        [ True,  True,  True,  True],
        [ True,  True,  True,  True]]])
```



# 单元小结

## `Numpy`库入门

+ 数据维度：一维、二维、多维、高维
+ `ndarray`数组是一个表示n维数据的数据类型
+ `ndarray`类型的属性
  + `.dim`
  + `.shape`
  + `.size`
  + `.dtype`
  + `.itemsize`
+ `ndarray`类型的创建
  + `np.arange(n)`
  + `np.ones(shape)`
  + `np.zeros(shape)`
  + `np.full(shape,val)`
  + `np.eye(n)`
  + `np.ones_like(a)`
  + `np.zeros_like(a)`
  + `np.full_like(a,val)`
+ `ndarray`类型的变换
  + `.reshape(shape)`
  + `.resize(shape)`
  + `.swapaxes(ax1,a2)`
  + `.flatten()`

+ 数组的索引和切片，切片使用单冒号和双冒号
+ 数组的运算：一元函数、二元函数